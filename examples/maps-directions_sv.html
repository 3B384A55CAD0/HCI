<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
		<script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCscKVyBTkwd83mGUN9J-BU459rgpfDlpc&sensor=false"></script>
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
		<script type="text/javascript">
			/*
				TODO
				- Mettere su uno script separato e farlo in modo che questa sia una classe dove le variabili (in questo caso globali) siano locali alla classe
				- Creare dei pulsanti di pausa, selezione dell'itinerario, ecc...
				- C'è da calcolare l'angolazione della camera di streetview
				- C'è da calcolare ogni quanto si deve muovere la camera della mappa (in questo momento si muove ogni tot passi)
				- Considerare se far stampare o no il polyline
			*/


			var map;
			var panorama;
			var polyline;
			var directionDisplay;
			var directionsService = new google.maps.DirectionsService();
			var distance;
			var zoom = 18;
			var mapBounds;
			var numCircles = 10;
			var circles = new Array(numCircles);
			var movementStep = 5;
			var mapMoveLap = 10;
			var mapMoveLapCounter = 0;
			var movementSleep = 100;

			$(document).ready(function() {
				var mapOptions = {
					center : new google.maps.LatLng(44.496, 11.338),
					zoom : zoom,
					mapTypeId : google.maps.MapTypeId.HYBRID
				};
				map = new google.maps.Map($("#map_canvas")[0], mapOptions);

				var panoramaOptions = {
				  position: new google.maps.LatLng(44.496, 11.338),
				  pov: {
				    heading: 34,
				    pitch: 10,
				    zoom: 1
				  }
				};
				//panorama = new  google.maps.StreetViewPanorama($("#map_canvas")[0], panoramaOptions);
				panorama = new  google.maps.StreetViewPanorama($("#map_streetview")[0], panoramaOptions);
				map.setStreetView(panorama);

				for(i = 0; i < numCircles; i++){
					circles[i] = new google.maps.Circle({
						fillColor: "#FF0000",
						strokeColor: "#FF0000",
						fillOpacity: 0.35,
						strokeOpacity: 0.8,
						strokeWeight: 1,
						map: map,
						center: new google.maps.LatLng(44.496, 11.338),
						radius: i/2
				    });
				}

				polyline = new google.maps.Polyline({
					path : [],
					strokeColor : '#00FF00',
					strokeWeight : 2
				});

				directionsDisplay = new google.maps.DirectionsRenderer({
					map : map
				});

			});

			function calculateRoute() {
				var request = {
					origin : "Casalecchio di Reno, BO, Italia",
					destination : "Bologna, BO, Italia",
					travelMode : google.maps.DirectionsTravelMode.DRIVING
				};
				directionsService.route(request, function(response, status) {
					//Il response è di tipo google.maps.DirectionsResult
					//ha routes che è una lista di google.maps.DirectionsRoute

					if (status == google.maps.DirectionsStatus.OK) {
						
						//la facciamo crescere in modo che contenga tutta la path
						var bounds = new google.maps.LatLngBounds();

						//Prendiamo solamente la prima route e prendiamo le google.maps.DirectionsLeg che
						//rappresentano una lista di google.maps.DirectionsStep
						//le legs contengono anche altre cose come la durata ecc...
						//Se non ci sono waypoints allora c'è solo un leg
						var legs = response.routes[0].legs;

						for (i = 0; i < legs.length; i++) {
							var steps = legs[i].steps;
							for (j = 0; j < steps.length; j++) {
								var segm = steps[j].path;
								for (k = 0; k < segm.length; k++) {
									polyline.getPath().push(segm[k]);
									bounds.extend(segm[k]);
								}
							}
						}

						polyline.setMap(map);
						distance = pathLength(polyline.getPath());
						$("#routeDistance").html(distanceToString(distance));
						var initialPoint = polyline.getPath().getAt(0);
						map.panTo(initialPoint);
						for(i=0; i < numCircles; i++){
							circles[i].setCenter(initialPoint);
						}
						animatePath(0);
						
						//directionsDisplay.setDirections(response);
					}
				});
			}
			
			// Calculate the distance of two point
			// http://en.wikipedia.org/wiki/Haversine_formula
			function latLngDistance(lat1, lng1, lat2, lng2) {
				var R = 6378136.6; //in metres (http://en.wikipedia.org/wiki/Figure_of_the_Earth)
				var dLat = (lat2-lat1) * Math.PI / 180; //(lat2-lat1).toRad()
				var dLon = (lng2-lng1) * Math.PI / 180; //(lng2-lng1).toRad()
				var a = Math.sin(dLat/2) * Math.sin(dLat/2) + 
						Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180);
				var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
				return R * c;
			}
			
			//Calculate the length of a path in metres
			function pathLength(path){
				var dist = 0;
				for (var i = 0; i < path.getLength() - 1; i++) {
					dist += latLngDistance(path.getAt(i).lat(), path.getAt(i).lng(), path.getAt(i+1).lat(), path.getAt(i+1).lng());
				}
				return dist;
			}

			//To print the current distance and the route distance
			function distanceToString(dist){
				return (dist/1000).toFixed(3) + " km";
			}
			
			//Get the point in the path that is at a distance #metres
			/* If metres <=0 it returns the first point of the path
			 * If metres > of the distance of the last point, it returns the last point */
			function getPathPointFromMetres(path, metres) {
				if (metres <= 0) return path.getAt(0);
				var i;
				var dist = new Array(0, 0);
				var p = new Array(null, path.getAt(0));
				/* Itero fino a quando trovo i due punti p[0] e p[1] che sono rispettivamente a distanza dist[0] e dist[1]
				 * dove dist[0] <= metres <= dist[1] 
				 * p[0] e p[1] sono consecutivi, quindi non esiste un p nella path con distanza dist tale che
				 * dist[0] < dist <= metres <= dist[1] oppure dist[0] <= metres <= dist < dist[1]
				 * cioè sono i punti più vicini possibile al punto che cerchiamo a distanza metres,
				 * questo ci assicura che in una curva il segmento ipotetico tra p[0] e p[1] sia sensato.
				 */
				for (i = 0; (i < path.getLength() - 1) && (dist[1] < metres); i++) {
					dist[0] = dist[1];
					p[0] = p[1];
					dist[1] += latLngDistance(path.getAt(i).lat(), path.getAt(i).lng(), path.getAt(i+1).lat(), path.getAt(i+1).lng());
					p[1] = path.getAt(i+1);
				}
 				if (dist[1] < metres) return path.getAt(path.getLength() - 1);

 				/* Visto che ho i due punti p[0] e p[1] rispettivamente a distanza dist[0] e dist[1]
				 * dove dist[0] <= metres <= dist[1], mi serve determinare il punto a distanza metres.
				 * Per fare questo parametrizzo il segmento identificato dai due punti p[0] e p[1] e successivamente
				 * prendo il punto del segmento in m = (metres - dist[1])/(dist[0] - dist[1])
				 */
				 if (dist[0] == dist[1]) return(p[0]);
				var m = (metres - dist[1])/(dist[0] - dist[1]);
				return new google.maps.LatLng(p[1].lat() + m * (p[0].lat() - p[1].lat()), p[1].lng() + m * (p[0].lng() - p[1].lng()));
			}
			
			function animatePath(metres){

				//Se abbiamo finito il percorso 
				if(metres >= distance) return;

				//Prendiamo la posizione ad un certo metro del nosto percorso
				var pos = getPathPointFromMetres(polyline.getPath(), metres);
				

				//Questo stabilisce ogni quano bisogna muovere il center della mappa
				//TODO: muovere osservando il bounds (in metri) della mappa e i passi (in metri) che sono stati fatti
				if(++mapMoveLapCounter >= mapMoveLap){
					map.panTo(pos);
					mapMoveLapCounter = 0;
				}

				//Calcolo delle posizioni dei cerchi----------------
				for(j = 0; j < numCircles - 1; j++){
					circles[j].setCenter(circles[j+1].getCenter());
				}
				circles[numCircles-1].setCenter(pos);
				//--------------------------------------------------

				//StreetView----------------
				panorama.setPosition(pos);
				//TODO: panorame.setPov(una certa StreetViewPov) (calcolare bene heading in base al passo precedente)
				//--------------------------
				 
				//Mostra la distanza attuale percorsa
				$("#currentDistance").html(distanceToString(metres));
				
				setTimeout("animatePath(" + (metres + movementStep) + ")", movementSleep);
			}



		</script>
	</head>
	<body>
		<div id="map_canvas" style="float:left; width:400px; height:400px"></div>
		<div id="map_streetview" style="float:left; width:400px; height:400px;"></div>
		
		<div style="width:100%; float:left;">
			<div>Route Distance: <span id="routeDistance"></span></div>
			<div>Current Distance: <span id="currentDistance"></span></div>
			
			<input type="button" onclick="calculateRoute()" value="Route" style="margin:20px;"/>
			<div id="tilesAreLoaded"></div>
		</div>
	</body>
</html>