<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
		<script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCscKVyBTkwd83mGUN9J-BU459rgpfDlpc&sensor=false"></script>
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
		<script type="text/javascript">
			/*
				TODO
				- Mettere su uno script separato e farlo in modo che questa sia una classe dove le variabili (in questo caso globali) siano locali alla classe
				- Creare dei pulsanti di pausa, selezione dell'itinerario, ecc...
				- C'è da calcolare l'angolazione della camera di streetview
				- C'è da calcolare ogni quanto si deve muovere la camera della mappa (in questo momento si muove ogni tot passi)
				- Considerare se far stampare o no il polyline
			*/

			var directionsService;

			var map;
			var panorama;
			
			var polyline;

			var distance;
			var zoom = 18;
			var mapBounds;
			var numCircles = 5;
			var circles = new Array(numCircles);
			var movementStep = 2;
			var mapMoveLap = 50;
			var mapMoveLapCounter = 0;
			var movementSleep = 100;

			$(document).ready(function() {

 				directionsService = new google.maps.DirectionsService();

				map = new google.maps.Map($("#map_canvas")[0], {
					center : new google.maps.LatLng(44.496, 11.338),
					zoom : zoom,
					mapTypeId : google.maps.MapTypeId.HYBRID
				});

				panorama = new  google.maps.StreetViewPanorama($("#map_streetview")[0], {
				  position: new google.maps.LatLng(44.496, 11.338),
				  pov: {
				    heading: 0,
				    pitch: 0,
				    zoom: 1
				  }
				});
				map.setStreetView(panorama);

			});

			function calculateRoute() {
				var request = {
					origin : "Casalecchio di Reno, BO, Italia",
					destination : "Bologna, BO, Italia",
					travelMode : google.maps.DirectionsTravelMode.DRIVING
				};
				directionsService.route(request, function(response, status) {
					//Il response è di tipo google.maps.DirectionsResult
					//ha routes che è una lista di google.maps.DirectionsRoute

					if (status == google.maps.DirectionsStatus.OK) {

						for(i = 0; i < numCircles; i++){
							circles[i] = new google.maps.Circle({
								fillColor: "#FF0000",
								strokeColor: "#FF0000",
								fillOpacity: 0.35,
								strokeOpacity: 0.8,
								strokeWeight: 1,
								center: new google.maps.LatLng(44.496, 11.338),
								radius: i/2
						    });
						}

						polyline = new google.maps.Polyline({
							path : [],
							strokeColor : '#00FF00',
							strokeWeight : 2
						});

						//Prendiamo solamente la prima route e prendiamo le google.maps.DirectionsLeg che
						//rappresentano una lista di google.maps.DirectionsStep
						//le legs contengono anche altre cose come la durata ecc...
						//Se non ci sono waypoints allora c'è solo un leg
						var legs = response.routes[0].legs;
						path = new Array();

						for (var i in legs){
							var steps = legs[i].steps;
							for (var j in steps){
								var points = steps[j].path;
								for (var k in points){
									polyline.getPath().push(points[k]);
								}
							}
						}

						polyline.setMap(map);

						distance = pathLength(polyline.getPath());
						
						//$("#routeDistance").html(distanceToString(distance));
						
						var initialPoint = polyline.getPath().getAt(0);
						map.panTo(initialPoint);
						for(i=0; i < numCircles; i++){
							circles[i].setMap(map);
							circles[i].setCenter(initialPoint);
						}

						animatePath(0);
						
						
					}
				});
			}
			
			// Calculate the distance of two point
			// http://en.wikipedia.org/wiki/Haversine_formula
			function latLngDistance(lat1, lng1, lat2, lng2) {
				var R = 6378136.6; //Earth radius in metres (http://en.wikipedia.org/wiki/Figure_of_the_Earth)
				var dLat = (lat2-lat1) * Math.PI / 180; //(lat2-lat1).toRad()
				var dLon = (lng2-lng1) * Math.PI / 180; //(lng2-lng1).toRad()
				var a = Math.sin(dLat/2) * Math.sin(dLat/2) + 
						Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180);
				var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
				return R * c;
			}
			
			//Calculate the length of a path in metres
			function pathLength(path){
				var dist = 0;
				for (var i = 0; i < path.getLength() - 1; i++) {
					dist += latLngDistance(path.getAt(i).lat(), path.getAt(i).lng(), path.getAt(i+1).lat(), path.getAt(i+1).lng());
				}
				return dist;
			}

			//To print the current distance and the route distance
			function distanceToString(dist){
				return (dist/1000).toFixed(3) + " km";
			}
			
			//Get the point in the path that is at a distance #metres
			/* If metres <=0 it returns the first point of the path
			 * If metres > of the distance of the last point, it returns the last point */
			function getPathPointFromMetres(path, metres) {
				if (metres <= 0) return path.getAt(0);
				var i;
				var dist = new Array(0, 0);
				var p = new Array(null, path.getAt(0));
				/* Itero fino a quando trovo i due punti p[0] e p[1] che sono rispettivamente a distanza dist[0] e dist[1]
				 * dove dist[0] <= metres <= dist[1] 
				 * p[0] e p[1] sono consecutivi, quindi non esiste un p nella path con distanza dist tale che
				 * dist[0] < dist <= metres <= dist[1] oppure dist[0] <= metres <= dist < dist[1]
				 * cioè sono i punti più vicini possibile al punto che cerchiamo a distanza metres,
				 * questo ci assicura che in una curva il segmento ipotetico tra p[0] e p[1] sia sensato.
				 */
				for (i = 0; (i < path.getLength() - 1) && (dist[1] < metres); i++) {
					dist[0] = dist[1];
					p[0] = p[1];
					dist[1] += latLngDistance(path.getAt(i).lat(), path.getAt(i).lng(), path.getAt(i+1).lat(), path.getAt(i+1).lng());
					p[1] = path.getAt(i+1);
				}
 				if (dist[1] < metres) return path.getAt(path.getLength() - 1);

 				/* Visto che ho i due punti p[0] e p[1] rispettivamente a distanza dist[0] e dist[1]
				 * dove dist[0] <= metres <= dist[1], mi serve determinare il punto a distanza metres.
				 * Per fare questo parametrizzo il segmento identificato dai due punti p[0] e p[1] e successivamente
				 * prendo il punto del segmento in m = (metres - dist[1])/(dist[0] - dist[1])
				 */
				 if (dist[0] == dist[1]) return(p[0]);
				var m = (metres - dist[1])/(dist[0] - dist[1]);
				return new google.maps.LatLng(p[1].lat() + m * (p[0].lat() - p[1].lat()), p[1].lng() + m * (p[0].lng() - p[1].lng()));
			}
			
			function animatePath(metres){

				//Se abbiamo finito il percorso 
				if(metres >= distance) return;

				//Prendiamo la posizione ad un certo metro del nosto percorso
				var pos = getPathPointFromMetres(polyline.getPath(), metres);
				

				//Questo stabilisce ogni quano bisogna muovere il center della mappa
				//TODO: muovere osservando il bounds (in metri) della mappa e i passi (in metri) che sono stati fatti
				if(++mapMoveLapCounter >= mapMoveLap){
					map.panTo(pos);
					mapMoveLapCounter = 0;
				}

				//Calcolo delle posizioni dei cerchi----------------
				for(j = 0; j < numCircles - 1; j++){
					circles[j].setCenter(circles[j+1].getCenter());
				}
				circles[numCircles-1].setCenter(pos);
				//--------------------------------------------------

				//StreetView----------------
				panorama.setPosition(pos);
				//TODO: panorama.setPov(una certa StreetViewPov) (calcolare bene heading in base al passo precedente)
				//TODO: rotazione heading				

				
				
				//distance1 = latLngDistance(circles[numCircles-2].getCenter().lat(), 0, circles[numCircles-1].getCenter().lat(), 0);
				//distance2 = latLngDistance(0, circles[numCircles-2].getCenter().lng(), 0, circles[numCircles-1].getCenter().lng());

				distance1 = circles[numCircles-1].getCenter().lat() - circles[0].getCenter().lat();
				distance2 = circles[numCircles-1].getCenter().lng() - circles[0].getCenter().lng();

				forwardAngle = Math.atan2(distance2, distance1) * (180/Math.PI);
				
				console.log(forwardAngle);

				panorama.setPov({
					heading: forwardAngle,
					pitch: 0,
					zoom: 1
				});
				//--------------------------
				 
				//Mostra la distanza attuale percorsa
				//$("#currentDistance").html(distanceToString(metres));
				
				setTimeout("animatePath(" + (metres + movementStep) + ")", movementSleep);
			}



		</script>
	</head>
	<body>
		<div id="map_canvas" style="float:left; width:400px; height:400px"></div>
		<div id="map_streetview" style="float:left; width:400px; height:400px;"></div>
		
		<div style="width:100%; float:left;">
			<div>Route Distance: <span id="routeDistance"></span></div>
			<div>Current Distance: <span id="currentDistance"></span></div>
			
			<input type="button" onclick="calculateRoute()" value="Route" style="margin:20px;"/>
			<div id="tilesAreLoaded"></div>
		</div>
	</body>
</html>
